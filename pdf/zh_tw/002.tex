\chapter{最小的“操作系統”} \label{CHsmall}

任何一個完善的操作系統都是從啟動扇區開始的，這一章，我們就關注如何寫一個啟動扇區，以及如何將其寫入到軟盤鏡像中。

先介紹一下需要使用的工具：
\begin{itemize}
\item{系統：} Cent OS 5.1(RHEL 5.1)
\item{使用工具：} gcc, binutils(as, ld, objcopy), dd, make, hexdump, vim, virtualbox
\end{itemize}

\section{Hello OS world!}\label{hello_OS_world}

\BOXED{0.9\textwidth}{
\danger\\ 本章節內容需要和~gcc, make~相關的~Linux C~語言編程以及~PC~匯編語言的基礎知識。\enddanger
}

\BOXED{0.9\textwidth}{
\danger\\推薦預備閱讀：CS:APP（Computer Systems: A Programmer's Perspective, 深入理解計算機系統）第~3~章：Machine-Level Representation of Programs。\enddanger
}

很多編程書籍給出的第一個例子往往是在終端裡輸出一個字符串“Hello world!”，那麼要寫操作系統的第一步給出的例子自然就是如何在屏幕上打印出一個字符串嘍。所以，我們首先看《自己動手寫操作系統》一書中給出的第一個示例代碼，在屏幕上打印“Hello OS world!”：

\begin{Codefrag}
    org    07c00h       ; 告訴編譯器程序加載到7c00處
    mov    ax, cs
    mov    ds, ax
    mov    es, ax
    call   DispStr      ; 調用顯示字符串例程
    jmp    $            ; 無限循環
DispStr:
    mov    ax, BootMessage
    mov    bp, ax       ; ES:BP = 串地址
    mov    cx, 16       ; CX = 串長度
    mov    ax, 01301h   ; AH = 13,  AL = 01h
    mov    bx, 000ch    ; 頁號為0(BH = 0) 黑底紅字(BL = 0Ch,高亮)
    mov    dl, 0
    int    10h          ; 10h 號中斷
    ret
BootMessage:     db    "Hello, OS world!"
times 510-($-$$) db    0 ; 填充剩下的空間，使生成的二進制代碼恰好為512字節
dw    0xaa55             ; 結束標志
\end{Codefrag}
\codecaption{《自》第一個實例代碼~boot.asm}\label{CHsmall_bootASM}

\subsection{Intel~匯編轉化為~AT\&T(GAS)~匯編}

上面~boot.asm~中代碼使用~Intel~風格的匯編語言寫成，本也可以在~Linux~下使用同樣開源的~NASM~編譯，但是鑑于很少有人在~Linux~下使用此匯編語法，它在~Linux~平台上的擴展性和可調試性都不好（~GCC~不兼容），而且不是採用~Linux~平台上編譯習慣，所以我把它改成了使用~GNU~工具鏈去編譯連接。這樣的話，對以後使用~GNU~工具鏈編寫其它體系結構的~bootloader~也有幫助，畢竟~NASM~沒有~GAS~用戶多（也許~\smiley）。

上面的匯編源程序可以改寫成~AT\&T~風格的匯編源代碼：

\begin{Codefrag}
.code16               #使用16位模式匯編
.text                 #代碼段開始
    mov    %cs,%ax
    mov    %ax,%ds
    mov    %ax,%es
    call   DispStr    #調用顯示字符串例程
    jmp    .          #無限循環
DispStr:
    mov    $BootMessage, %ax
    mov    %ax,%bp        #ES:BP = 串地址
    mov    $16,%cx        #CX = 串長度
    mov    $0x1301,%ax    #AH = 13,  AL = 01h
    mov    $0x00c,%bx     #頁號為0(BH = 0) 黑底紅字(BL = 0Ch,高亮)
    mov    $0,%dl
    int    $0x10          #10h 號中斷
    ret
BootMessage:.ascii "Hello, OS world!"
.org 510             #填充到~510~字節處
.word 0xaa55         #結束標志
\end{Codefrag}
\codecaption{boot.S(chapter2/1/boot.S)}\label{CHsmall_bootS}

\subsection{用連接腳本控制地址空間}

但有一個問題,我們可以使用~\code{nasm boot.asm -o boot.bin}~命令將~boot.asm~直接編譯成二進制文件，~GAS~不能。不過~GAS~的不能恰好給開發者一個機會去分步地實現從匯編源代碼到二進制文件這個過程，使編譯更為靈活。下面請看~GAS~是如何通過連接腳本控制程序地址空間的：

\VerbatimInput[fontfamily=tt,fontsize=\footnotesize,frame=lines, framerule=0.4mm, numbers=left, numbersep=3pt, tabsize=2, firstline=11]{../../src/chapter2/1/solrex_x86.ld}
\codecaption{boot.S~的連接腳本~(chapter2/1/solrex\_x86.ld)}\label{CHsmall_solrexLD}

\BOXED{0.9\textwidth}{
~~~~\textbf{連接腳本}~：~GNU~連接器~ld~的每一個連接過程都由連接腳本控制。連接腳本主要用于，怎樣把輸入文件內的~section~放入輸出文件內，並且控制輸出文件內各部分在程序地址空間內的布局。連接器有個默認的內置連接腳本，可以用命令~ld --verbose~查看。選項~-T~選項可以指定自己的連接腳本，它將代替默認的連接腳本。
}

這個連接腳本的功能就是，在連接的時候，將程序入口設置為內存~\code{0x7c00}~的位置（~BOIS~將跳轉到這裡繼續啟動過程），相當于~boot.asm~中的~org 07c00h~一句。有人可能覺得麻煩，還需要用一個腳本控制加載地址，但是《自己動手寫操作系統》就給了一個很好的反例：《自》第~1.5~節代碼~1-2~,作者切換調試和運行模式時候需要對代碼進行注釋。

\begin{Codefrag}
;%define _BOOT_DEBUG_   ; 做 Boot Sector 時一定將此行注釋掉!將此行打開後用
                        ; nasm Boot.asm -o Boot.com 做成一個.COM文件易于調試

%ifdef _BOOT_DEBUG_
    org  0100h     ; 調試狀態, 做成 .COM 文件, 可調試
%else
    org  07c00h    ; Boot 狀態, Bios 將把 Boot Sector 加載到 0:7C00 處並開始執行
%endif

    mov    ax, cs
    mov    ds, ax
    mov    es, ax
    call   DispStr      ; 調用顯示字符串例程
    jmp    $            ; 無限循環
DispStr:
    mov    ax, BootMessage
    mov    bp, ax       ; ES:BP = 串地址
    mov    cx, 16       ; CX = 串長度
    mov    ax, 01301h   ; AH = 13,  AL = 01h
    mov    bx, 000ch    ; 頁號為0(BH = 0) 黑底紅字(BL = 0Ch,高亮)
    mov    dl, 0
    int    10h          ; 10h 號中斷
    ret
BootMessage:     db    "Hello, OS world!"
times 510-($-$$) db    0 ; 填充剩下的空間，使生成的二進制代碼恰好為512字節
dw    0xaa55             ; 結束標志
\end{Codefrag}
\codecaption{《自》代碼~1-2~(chapter2/1/boot.asm)}\label{CHsmall_bootASM1}

而如果換成使用腳本控制程序地址空間，只需要編譯時候調用不同腳本進行連接，就能解決這個問題。這在嵌入式編程中是很常見的處理方式，即使用不同的連接腳本一次~make~從一個源程序文件生成分別運行在開發板上和軟件模擬器上的兩個二進制文件 。

\subsection{用~Makefile~編譯連接}

下面的這個~Makefile~文件，就是我們用來自動編譯~boot.S~匯編源代碼的腳本文件：

\begin{Codefrag}
CC=gcc
LD=ld
LDFILE=solrex_x86.ld    #使用上面提供的連接腳本 solrex_x86.ld
OBJCOPY=objcopy

all: boot.img

# Step 1: gcc 調用 as 將 boot.S 編譯成目標文件 boot.o
boot.o: boot.S
        $(CC) -c boot.S

# Step 2: ld 調用連接腳本 solrex_x86.ld 將 boot.o 連接成可執行文件 boot.elf
boot.elf: boot.o
        $(LD) boot.o -o boot.elf -e c -T$(LDFILE)

# Step 3: objcopy 移除 boot.elf 中沒有用的 section(.pdr,.comment,.note),
#         strip 掉所有符號信息，輸出為二進制文件 boot.bin 。
boot.bin : boot.elf
        @$(OBJCOPY) -R .pdr -R .comment -R.note -S -O binary boot.elf boot.bin

# Step 4: 生成可啟動軟盤鏡像。 
boot.img: boot.bin
        @dd if=boot.bin of=boot.img bs=512 count=1             #用 boot.bin 生成鏡像文件第一個扇區
        # 在 bin 生成的鏡像文件後補上空白，最後成為合適大小的軟盤鏡像
        @dd if=/dev/zero of=boot.img skip=1 seek=1 bs=512 count=2879

clean:
        @rm -rf boot.o boot.elf boot.bin boot.img
\end{Codefrag}
\codecaption{boot.S~的~Makefile(chapter2/1/Makefile)}\label{CHsmall_Makefile}

我們將上面內容保存成~Makefile~，與圖~\ref{CHsmall_bootS}~所示~boog.S~和圖~\ref{CHsmall_solrexLD}~所示~solrex\_x86.ld~放在同一個目錄下，然後在此目錄下使用下面命令編譯：

\begin{Command}
$ make
gcc -c boot.S 
ld boot.o -o boot.elf -Tsolrex_x86.ld
1+0 records in
1+0 records out
512 bytes (512 B) copied, 3.1289e-05 seconds, 16.4 MB/s
2879+0 records in
2879+0 records out
1474048 bytes (1.5 MB) copied, 0.0141508 seconds, 104 MB/s
$ ls
boot.asm  boot.elf  boot.o  Makefile    solrex_x86.ld
boot.bin  boot.img  boot.S  solrex.img
\end{Command}

可以看到，我們只需執行一條命令~\code{make}~就可以編譯、連接和直接生成可啟動的軟盤鏡像文件，其間對源文件的每一步處理也都一清二楚。不用任何商業軟件，也不用自己寫任何轉換工具，比如《自己動手寫操作系統》文中提到的~HD-COPY~和~Floopy Writer~都沒有使用到。 

在這裡需要特別注意的是圖~\ref{CHsmall_Makefile}~中的~Step 4，其實對這一步的解釋應該結合圖~\ref{bootsector1}~來查看。我們用~boot.S~編譯生成的~boot.bin~其實只是圖~\ref{bootsector1}~中所指的軟盤的啟動扇區，例如~boot.S~最後一行：
\begin{Command}
.word 0xaa55         #結束標志
\end{Command}
生成就是啟動扇區最後的~\code{0xaa55}~那兩個字節，而~boot.bin~的大小是~512~字節，正好是啟動扇區的大小。那麼~Step 4~的功能就是把~boot.bin~放入到一個空白軟盤的啟動扇區，這樣呢當虛擬機啟動時能識別出這是一張可啟動軟盤，並且執行我們在啟動扇區中寫入的打印代碼。

為了驗證軟盤鏡像文件的正確性也可以先用
\begin{Command}
$ hexdump -x -n 512 boot.img
\end{Command}
將~boot.img~前~512~個字節打印出來，可以看到~boot.img dump~的內容和《自》一書附送光盤中的~TINIX.IMG dump~的內容完全相同。
這裡我們也顯然用不到~EditPlus~或者~UltraEdit~，即使需要修改二進制碼，也可以使用~hexedit, ghex2, khexedit~等工具對二進制文件進行修改。

下圖為使用命令行工具~hexedit~打開~boot.img~的窗口截圖，從圖中我們可以看到，左列是該行開頭與文件頭對應的偏移地址，中間一列是文件的二進制內容，最右列是文件內容的~ASCII~顯示內容，可以看到，此界面與~UltraEdit~的十六進制編輯界面沒有本質不同。

\FIGFIX{使用~hexedit~打開~boot.img}{hexedit}{0.75\textwidth}

\FIGFIX{使用~kde~圖形界面工具~khexedit~打開~boot.img}{khexedit}{0.75\textwidth}

\subsection{用虛擬機加載執行~boot.img}

當我們生成~boot.img~之後，仿照第~\ref{CHboot_fboot}~節中加載軟盤鏡像的方法，用虛擬機加載~boot.img:\\
\FIGFIX{選擇啟動軟盤鏡像~boot.img}{vb_set_6}{0.75\textwidth}

\FIGFIX{虛擬機啟動後打印出紅色的“Hello OS world!”}{vb_run_2}{0.75\textwidth}

我們看到虛擬機如我們所料的打印出了紅色的“Hello OS world!”字樣，這說明我們以上的程序和編譯過程是正確的。

\section{FAT~文件系統}

我們在上一節中介紹的內容，僅僅是寫一個啟動扇區並將其放入軟盤鏡像的合適位置。由于啟動扇區~512~字節的大小限制，我們僅僅能寫入像打印一個字符串這樣的非常簡單的程序，那麼如何突破~512~字節的限制呢？很顯然的答案是我們要利用其它的扇區，將程序保存在其它扇區，運行前將其加載到內存後再跳轉過去執行。那麼又一個問題產生了：程序在軟盤上應該怎樣存儲呢？

可能最直接最容易理解的存儲方式就是順序存儲，即將一個大程序從啟動扇區開始按順序存儲在相鄰的扇區，可能這樣需要的工作量最小，在啟動時操作系統僅僅需要序列地將可執行代碼拷貝到內存中來繼續運行。可是經過簡單的思考我們就可以發現這樣做有幾個缺陷：1. 軟盤中僅能存儲操作系統程序，無法存儲其它內容；2. 我們必須使用二進制拷貝方式來制作軟盤鏡像，修改系統麻煩。

那麼怎麼避免這兩個缺點呢？引入文件系統可以讓我們在一張軟盤上存儲不同的文件，並提供文件管理功能，可以讓我們避免上述的兩個缺點。在使用某種文件系統對軟盤格式化之後，我們可以像普通軟盤一樣使用它來存儲多個文件和目錄，為了使用軟盤上的文件，我們給啟動扇區的代碼加上尋找文件和加載執行文件功能，讓啟動扇區將系統控制權轉移給軟盤上的某個文件，這樣突破啟動扇區~512~字節大小的限制。

\subsection{FAT12~文件系統}

FAT(File Allocation Table)~文件系統規格在~20~世紀~70~年代末和~80~年代初形成，是微軟的~MS-DOS~操作系統使用的文件系統格式。它的初衷是為小于~500K~容量的軟盤制定的簡單文件系統，但在將近三十年的發展過程中，它已經被一次次修改加強以支持更大的存儲媒體。在目前主要有三種~FAT~文件系統類型：FAT12, FAT16~和~FAT32。這幾種類型最基本的區別就像它們的名字字面區別一樣，主要在于大小，即盤上~FAT~表的記錄項所佔的比特數。FAT12~的記錄項佔~12~比特，FAT16~佔~16~比特，FAT32~佔~32~比特。

由于~FAT12~最為簡單和易實施，這裡我們僅簡單介紹~FAT12~文件系統，想要了解更多~FAT~文件系統知識的話，可以到~\url{http://www.microsoft.com/whdc/system/platform/firmware/fatgen.mspx}~下載微軟發布的~FAT~文件系統官方文檔。

FAT12~文件系統和其它文件系統一樣，都將磁盤劃分為層次進行管理。從邏輯上劃分，一般將磁盤劃分為盤符，目錄和文件；從抽象物理結構來講，將磁盤劃分為分區，簇和扇區。那麼，如何將邏輯上的目錄和文件映射到物理上實際的簇和扇區，就是文件系統要解決的問題。

如果讓虛擬機直接讀取我們上一節生成的可啟動軟盤鏡像，或者將~boot.img~軟盤用~\code{mount -o loop boot.img mountdir/}~掛載到某個目錄上，系統肯定會報出“軟盤未格式化”或者“文件格式不可識別”的錯誤。這是因為任何系統可讀取的軟盤都是被格式化過的，而我們的~boot.img~是一個非常原始的軟盤鏡像。那麼如何才能使軟盤被識別為~FAT12~格式的軟盤並且可以像普通軟盤一樣存取呢？

系統在讀取一張軟盤的時候，會讀取軟盤上存儲的一些關于文件系統的信息，軟盤格式化的過程也就是系統把文件系統信息寫入到軟盤上的過程。但是我們不能讓系統來格式化我們的~boot.img~，如果那樣的話，我們寫入的啟動程序也會被擦除。所以呢，我們需要自己對軟盤進行格式化。\blacksmiley 可能有人看到這裡就會很沮喪，天那，那該有多麻煩啊！不過我相信在讀完以下內容以後你會歡呼雀躍，啊哈，原來文件系統挺簡單的嘛！

\subsection{啟動扇區與~BPB}

FAT~文件系統的主要信息，都被提供在前幾個扇區內，其中第~0~號扇區尤其重要。在這個扇區內隱藏著一個叫做~BPB(BIOS Parameter Block)~的數據結構，一旦我們把這個數據結構寫對了，格式化過程也基本完成了 \smiley。下面這個表中所示內容，主要就是啟動扇區的~BPB~數據結構。

\texttt{
\begin{center}\begin{longtable}{l|c|c|l|l}
\caption[]{啟動扇區的~BPB~數據結構和其它內容}\label{bootsec_BPB}\\
\hline
名稱 &偏移 &大小 & 描述 & Solrex.img\\
     &bytes&bytes&      & 文件中的值\\
\hline
BS\_jmpBoot     & 0  &  3 & 跳轉指令，用于跳過以下的扇區信息        & jmp LABEL\_START \\
                &    &    &                                         & nop \\
\hline
BS\_OEMName     &  3 &  8 & 廠商名                                  & "WB. YANG"\\
\hline
BPB\_BytesPerSec& 11 &  2 & 扇區大小（字節），應為 512              & 512\\
\hline
BPB\_secPerClus & 13 &  1 & 簇的扇區數，應為 2 的冪，FAT12 為 1     & 1\\
\hline
BPB\_RsvdSecCnt & 14 &  2 & 保留扇區，FAT12/16 應為 1               & 1\\
\hline
BPB\_NumFATs    & 16 &  1 & FAT 結構數目，一般為 2                  & 2\\
\hline
BPB\_RootEntCnt & 17 &  2 & 根目錄項目數，FAT12 為 224              & 224\\
\hline
BPB\_TotSec16   & 19 &  2 & 扇區總數，1.44M 軟盤為 2880             & 2880\\
\hline
BPB\_Media      & 21 &  1 & 設備類型，1.44M 軟盤為 F0h              & 0xf0\\
\hline
BPB\_FATSz16    & 22 &  2 & FAT 佔用扇區數，9                       & 9\\
\hline
BPB\_SecPerTrk  & 24 &  2 & 磁道扇區數，18                          & 18\\
\hline
BPB\_NumHeads   & 26 &  2 & 磁頭數，2                               & 2\\
\hline
BPB\_HiddSec    & 28 &  4 & 隱藏扇區，默認為 0                      & 0\\
\hline
BPB\_TotSec32   & 32 &  4 & 如果~BPB\_TotSec16~為~0，它記錄總扇區數 & 0\\
\hline
\multicolumn{5}{c}{下面的扇區頭信息~FAT12/FAT16~與~FAT32 不同}\\
\hline
BS\_DrvNum      & 36 &  1 & 中斷~0x13~的驅動器參數，0~為軟盤        & 0\\
\hline
BS\_Reserved1   & 37 &  1 & Windows NT 使用，0                      & 0\\
\hline
BS\_BootSig     & 38 &  1 & 擴展引導標記~(29h)，指明此後~3~個域可用 & 0x29\\
\hline
BS\_VolID       & 39 &  4 & 卷標序列號，00000000h                   & 0\\
\hline
BS\_VolLab      & 43 & 11 & 卷標，11 字節，必須用空格 20h 補齊      & "Solrex 0.01"\\
\hline
BS\_FilSysType  & 54 &  8 & 文件系統標志，"FAT12~~~"                & "FAT12~~~"\\
\hline
\multicolumn{5}{c}{以下為非扇區頭信息部分}\\
\hline
啟動代碼及其它  & 62 & 448 & 啟動代碼、數據及填充字符               & mov \%cs,\%ax...\\
\hline
啟動扇區標識符  & 510 &  2 & 可啟動扇區標志，0xAA55                 & 0xaa55\\
\hline
\end{longtable}\end{center}
}

哇，天那，這個~BPB~看起來很多東西的嘛，怎麼寫啊？其實寫入這些信息很簡單，因為它們都是固定不變的內容，用下面的代碼就可以實現。

\VerbatimInput[fontfamily=tt,fontsize=\footnotesize,frame=lines, framerule=0.4mm, numbers=left, numbersep=3pt, tabsize=2, firstline=21, lastline=45]{../../src/chapter2/2/boot.S}
\codecaption{生成啟動扇區頭的匯編代碼(節自 chapter2/2/boot.S)}\label{CHsmall_bootS1}

在上面的匯編代碼中，我們只是順序地用字符填充了啟動扇區頭的數據結構，填充的內容與表~\ref{bootsec_BPB}~中最後一列的內容相對應。把圖~\ref{CHsmall_bootS1}~中所示代碼添加到圖~\ref{CHsmall_bootS}~的第二行和第三行之間，然後再~make~，就能得到一張已經被格式化，可啟動也可存儲文件的軟盤，就是既可以使用~\code{mount -o loop boot.img mountdir/}~命令在普通~Linux~系統裡掛載，也可用作虛擬機啟動的軟盤鏡像文件。

\subsection{FAT12~數據結構}

在上一個小節裡，我們制作出了可以當作普通軟盤使用的啟動軟盤，這樣我們就可以在這張軟盤上存儲多個文件了。可還有一步要求我們沒有達到，怎樣尋找存儲的某個引導文件並將其加載到內存中運行呢？這就涉及到~FAT12~文件系統中文件的存儲方式了，需要我們了解一些~FAT~數據結構和目錄結構的知識。

FAT~文件系統對存儲空間分配的最小單位是“簇”，因此文件在佔用存儲空間時，基本單位是簇而不是字節。即使文件僅僅有~1~字節大小，系統也必須分給它一個最小存儲單元
